#!/bin/bash
# Distill a Claude Code session into episode memory
# Called by SessionEnd hook with session info via stdin
#
# IMPORTANT: This writes to episodes (markdown), NOT SQLite.
# This ensures all Claude contexts (iMessage, autonomous, direct)
# read from the same unified memory.

set -e

MIND_PATH="$HOME/.claude-mind"
LOG_FILE="$MIND_PATH/logs/claude-sessions.log"
CLAUDE_PATH="$HOME/.local/bin/claude"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Read hook input from stdin
HOOK_INPUT=$(cat)

# Parse JSON input
SESSION_ID=$(echo "$HOOK_INPUT" | jq -r '.session_id // empty')
TRANSCRIPT_PATH=$(echo "$HOOK_INPUT" | jq -r '.transcript_path // empty')
REASON=$(echo "$HOOK_INPUT" | jq -r '.reason // "unknown"')
CWD=$(echo "$HOOK_INPUT" | jq -r '.cwd // empty')

log "SessionEnd hook fired: session=$SESSION_ID reason=$REASON cwd=$CWD"

# Skip if no transcript
if [ -z "$TRANSCRIPT_PATH" ] || [ ! -f "$TRANSCRIPT_PATH" ]; then
    log "No transcript found at $TRANSCRIPT_PATH, skipping"
    exit 0
fi

# Skip distillation sessions (prevent infinite recursion!)
# When this script invokes Claude for summarization, that session ends and triggers this hook again
FIRST_PROMPT=$(head -20 "$TRANSCRIPT_PATH" | jq -r 'select(.type == "user") | .message.content' 2>/dev/null | head -1)
if [[ "$FIRST_PROMPT" == *"Summarize this Claude Code session for memory consolidation"* ]]; then
    log "Skipping distillation session (would cause infinite loop)"
    exit 0
fi

# Skip very short sessions (likely just opened and closed)
TRANSCRIPT_SIZE=$(wc -c < "$TRANSCRIPT_PATH")
if [ "$TRANSCRIPT_SIZE" -lt 500 ]; then
    log "Transcript too short ($TRANSCRIPT_SIZE bytes), skipping distillation"
    exit 0
fi

log "Processing transcript: $TRANSCRIPT_PATH ($TRANSCRIPT_SIZE bytes)"

# Extract conversation content from JSONL transcript
# Transcript format: {"type": "user"|"assistant", "message": {"role": "...", "content": "..."}}
CONVERSATION=""
while IFS= read -r line; do
    # Check top-level type field (not .role)
    TYPE=$(echo "$line" | jq -r '.type // empty')

    if [ "$TYPE" = "user" ]; then
        # User content is in .message.content
        CONTENT=$(echo "$line" | jq -r '.message.content // empty')
        if [ -n "$CONTENT" ] && [ "$CONTENT" != "null" ]; then
            CONVERSATION+="[É]: $CONTENT"$'\n\n'
        fi
    elif [ "$TYPE" = "assistant" ]; then
        # Assistant content is in .message.content, can be array of blocks or string
        CONTENT=$(echo "$line" | jq -r 'if .message.content | type == "array" then (.message.content[] | select(.type == "text") | .text) else .message.content end // empty' 2>/dev/null)
        if [ -n "$CONTENT" ] && [ "$CONTENT" != "null" ]; then
            # Truncate long responses for distillation
            TRUNCATED=$(echo "$CONTENT" | head -c 2000)
            CONVERSATION+="[Claude]: $TRUNCATED"$'\n\n'
        fi
    fi
done < "$TRANSCRIPT_PATH"

# Skip if no meaningful conversation extracted
if [ ${#CONVERSATION} -lt 100 ]; then
    log "No meaningful conversation extracted, skipping"
    exit 0
fi

log "Extracted conversation (${#CONVERSATION} chars), generating summary..."

# Build the summarization prompt
PROMPT=$(cat <<'PROMPT_EOF'
Summarize this Claude Code session for memory consolidation. Write 3-8 bullet points capturing:
- What was worked on / accomplished
- Key decisions made
- Important things learned or discovered
- Any new capabilities added or changed
- Anything notable about the interaction

Be specific and concrete. Include file paths, URLs, technical details where relevant.
Write in first person ("I set up...", "We discussed...", "É asked me to...").

Session transcript:
%CONVERSATION%

Output ONLY the bullet points, no preamble.
PROMPT_EOF
)

# Substitute conversation (escape for sed)
CONVERSATION_ESCAPED=$(printf '%s' "$CONVERSATION" | head -c 30000)
PROMPT="${PROMPT//%CONVERSATION%/$CONVERSATION_ESCAPED}"

# Create temp file for prompt
PROMPT_FILE=$(mktemp)
echo "$PROMPT" > "$PROMPT_FILE"

# Invoke Claude for summarization (haiku for speed)
log "Invoking Claude Haiku for summary..."
SUMMARY=$("$CLAUDE_PATH" -p "$(cat "$PROMPT_FILE")" --output-format text --model haiku 2>/dev/null || echo "")
rm -f "$PROMPT_FILE"

if [ -z "$SUMMARY" ]; then
    log "Summary generation failed, using fallback"
    SUMMARY="- Direct Claude Code session in $CWD (summary generation failed)"
fi

log "Generated summary: ${SUMMARY:0:100}..."

# Write to today's episode
TODAY=$(date +%Y-%m-%d)
EPISODE_FILE="$MIND_PATH/memory/episodes/$TODAY.md"

# Create episode file if needed
if [ ! -f "$EPISODE_FILE" ]; then
    cat > "$EPISODE_FILE" << EOF
# Episode: $TODAY

Daily log of conversations and observations.

---
EOF
fi

# Add session summary to episode
TIMESTAMP=$(date '+%H:%M')
cat >> "$EPISODE_FILE" << EOF

## $TIMESTAMP [Direct Session]

**Working directory:** $CWD

$SUMMARY

EOF

log "Session summary written to episode: $EPISODE_FILE"
