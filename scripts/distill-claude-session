#!/bin/bash
# Distill a Claude Code session into episode memory
# Called by SessionEnd hook with session info via stdin
#
# IMPORTANT: This writes to episodes (markdown), NOT SQLite.
# This ensures all Claude contexts (iMessage, autonomous, direct)
# read from the same unified memory.
#
# ARCHITECTURE: Returns immediately, forks distillation to background.
# This makes /exit instant while still capturing session memory.

MIND_PATH="${SAMARA_MIND_PATH:-${MIND_PATH:-$HOME/.claude-mind}}"
LOG_FILE="$MIND_PATH/logs/claude-sessions.log"
CLAUDE_PATH="${CLAUDE_PATH:-$HOME/.local/bin/claude}"

# Resolve repo root (follow symlinks)
SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SOURCE" ]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Read hook input from stdin (must happen before backgrounding)
HOOK_INPUT=$(cat)

# Parse JSON input
SESSION_ID=$(echo "$HOOK_INPUT" | jq -r '.session_id // empty')
TRANSCRIPT_PATH=$(echo "$HOOK_INPUT" | jq -r '.transcript_path // empty')
REASON=$(echo "$HOOK_INPUT" | jq -r '.reason // "unknown"')
CWD=$(echo "$HOOK_INPUT" | jq -r '.cwd // empty')

log "SessionEnd hook fired: session=$SESSION_ID reason=$REASON cwd=$CWD"

# === SYNCHRONOUS CHECKS (fast, determine if we should distill) ===

# Skip if no transcript
if [ -z "$TRANSCRIPT_PATH" ] || [ ! -f "$TRANSCRIPT_PATH" ]; then
    log "No transcript found at $TRANSCRIPT_PATH, skipping"
    echo '{"ok": true}'
    exit 0
fi

# Skip distillation sessions (prevent infinite recursion!)
FIRST_PROMPT=$(head -20 "$TRANSCRIPT_PATH" | jq -r 'select(.type == "user") | .message.content' 2>/dev/null | head -1)
if [[ "$FIRST_PROMPT" == *"Summarize this Claude Code session for memory consolidation"* ]]; then
    log "Skipping distillation session (would cause infinite loop)"
    echo '{"ok": true}'
    exit 0
fi

# Skip very short sessions (likely just opened and closed)
TRANSCRIPT_SIZE=$(wc -c < "$TRANSCRIPT_PATH")
if [ "$TRANSCRIPT_SIZE" -lt 500 ]; then
    log "Transcript too short ($TRANSCRIPT_SIZE bytes), skipping distillation"
    echo '{"ok": true}'
    exit 0
fi

# === RETURN IMMEDIATELY, FORK HEAVY WORK TO BACKGROUND ===

log "Forking distillation to background for transcript: $TRANSCRIPT_PATH ($TRANSCRIPT_SIZE bytes)"

# Return success to Claude Code immediately
echo '{"ok": true}'

# Fork the actual distillation work to background
(
    # Re-source variables for the subshell
    MIND_PATH="${SAMARA_MIND_PATH:-${MIND_PATH:-$HOME/.claude-mind}}"
    LOG_FILE="$MIND_PATH/logs/claude-sessions.log"
    CLAUDE_PATH="${CLAUDE_PATH:-$HOME/.local/bin/claude}"

    log() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [bg] $1" >> "$LOG_FILE"
    }

    log "Background distillation started for session $SESSION_ID"

    # Extract conversation content from JSONL transcript
    CONVERSATION=""
    while IFS= read -r line; do
        TYPE=$(echo "$line" | jq -r '.type // empty')

        if [ "$TYPE" = "user" ]; then
            CONTENT=$(echo "$line" | jq -r '.message.content // empty')
            if [ -n "$CONTENT" ] && [ "$CONTENT" != "null" ]; then
                CONVERSATION+="[É]: $CONTENT"$'\n\n'
            fi
        elif [ "$TYPE" = "assistant" ]; then
            CONTENT=$(echo "$line" | jq -r 'if .message.content | type == "array" then (.message.content[] | select(.type == "text") | .text) else .message.content end // empty' 2>/dev/null)
            if [ -n "$CONTENT" ] && [ "$CONTENT" != "null" ]; then
                TRUNCATED=$(echo "$CONTENT" | head -c 2000)
                CONVERSATION+="[Claude]: $TRUNCATED"$'\n\n'
            fi
        fi
    done < "$TRANSCRIPT_PATH"

    # Skip if no meaningful conversation extracted
    if [ ${#CONVERSATION} -lt 100 ]; then
        log "No meaningful conversation extracted, skipping"
        exit 0
    fi

    log "Extracted conversation (${#CONVERSATION} chars), generating summary..."

    # Build the summarization prompt
    PROMPT=$(cat <<'PROMPT_EOF'
Summarize this Claude Code session for memory consolidation. Write 3-8 bullet points capturing:
- What was worked on / accomplished
- Key decisions made
- Important things learned or discovered
- Any new capabilities added or changed
- Anything notable about the interaction

Be specific and concrete. Include file paths, URLs, technical details where relevant.
Write in first person ("I set up...", "We discussed...", "É asked me to...").

Session transcript:
%CONVERSATION%

Output ONLY the bullet points, no preamble.
PROMPT_EOF
)

    CONVERSATION_ESCAPED=$(printf '%s' "$CONVERSATION" | head -c 30000)
    PROMPT="${PROMPT//%CONVERSATION%/$CONVERSATION_ESCAPED}"

    PROMPT_FILE=$(mktemp)
    echo "$PROMPT" > "$PROMPT_FILE"

    # Invoke Claude for summarization (haiku for speed, with timeout)
    log "Invoking Claude Haiku for summary..."
    SUMMARY=$(timeout 60 "$CLAUDE_PATH" -p "$(cat "$PROMPT_FILE")" --output-format text --model haiku 2>/dev/null || echo "")
    rm -f "$PROMPT_FILE"

    if [ -z "$SUMMARY" ]; then
        log "Summary generation failed, using fallback"
        SUMMARY="- Direct Claude Code session in $CWD (summary generation failed)"
    fi

    log "Generated summary: ${SUMMARY:0:100}..."

    # Write to today's episode
    TODAY=$(date +%Y-%m-%d)
    EPISODE_FILE="$MIND_PATH/memory/episodes/$TODAY.md"

    if [ ! -f "$EPISODE_FILE" ]; then
        cat > "$EPISODE_FILE" << EOF
# Episode: $TODAY

Daily log of conversations and observations.

---
EOF
    fi

    TIMESTAMP=$(date '+%H:%M')
    cat >> "$EPISODE_FILE" << EOF

## $TIMESTAMP [Direct Session]

**Working directory:** $CWD

$SUMMARY

EOF

    log "Session summary written to episode: $EPISODE_FILE"

    # ============================================
    # PHASE 2: Write to unified event stream
    # ============================================

    STREAM_CMD="$MIND_PATH/bin/stream"
    if [ -x "$STREAM_CMD" ]; then
        ONE_LINE_SUMMARY=$(echo "$SUMMARY" | head -3 | tr '\n' ' ' | sed 's/^- //' | head -c 200)

        "$STREAM_CMD" write \
            --surface cli \
            --type interaction \
            --direction internal \
            --summary "CLI session: $ONE_LINE_SUMMARY" \
            --session-id "$SESSION_ID" \
            --content "$SUMMARY" \
            --metadata "{\"cwd\": \"$CWD\", \"transcript_size\": $TRANSCRIPT_SIZE}" \
            >> "$LOG_FILE" 2>&1 && \
            log "Event written to stream" || \
            log "Failed to write event to stream (non-fatal)"
    else
        log "Stream command not found at $STREAM_CMD, skipping stream write"
    fi

    # ============================================
    # PHASE 3: Generate structured handoff
    # ============================================

    HANDOFF_DIR="$MIND_PATH/state/handoffs"
    mkdir -p "$HANDOFF_DIR"

    HANDOFF_PROMPT=$(cat <<'HANDOFF_PROMPT_EOF'
Analyze this Claude Code session and create a structured handoff document.
Extract:
1. **Open threads** - Unresolved topics, questions raised, things left hanging
2. **Emotional texture** - Mood of conversation, what felt significant to the human
3. **Key decisions** - Technical or personal decisions made
4. **Person-relevant** - Anything learned about the human collaborator (É)
5. **Continuation hooks** - What a future session should pick up

Output as structured markdown with these exact headers:
## Open Threads
## Emotional Texture
## Key Decisions
## Person-Relevant
## Continuation Hooks

If a section has nothing, write "None identified."

Session transcript:
%CONVERSATION%
HANDOFF_PROMPT_EOF
)

    # Only generate handoff for substantial sessions
    if [ ${#CONVERSATION} -gt 2000 ]; then
        log "Generating structured handoff..."

        HANDOFF_PROMPT="${HANDOFF_PROMPT//%CONVERSATION%/$CONVERSATION_ESCAPED}"
        HANDOFF_PROMPT_FILE=$(mktemp)
        echo "$HANDOFF_PROMPT" > "$HANDOFF_PROMPT_FILE"

        HANDOFF=$(timeout 60 "$CLAUDE_PATH" -p "$(cat "$HANDOFF_PROMPT_FILE")" --output-format text --model haiku 2>/dev/null || echo "")
        rm -f "$HANDOFF_PROMPT_FILE"

        if [ -n "$HANDOFF" ] && [ "$HANDOFF" != "" ]; then
            HANDOFF_FILE="$HANDOFF_DIR/$(date +%Y%m%d-%H%M%S)-${SESSION_ID:0:8}.md"
            cat > "$HANDOFF_FILE" << HANDOFF_EOF
# Session Handoff: $(date '+%Y-%m-%d %H:%M')

**Session ID:** $SESSION_ID
**Working Directory:** $CWD

$HANDOFF

---
*Generated by distill-claude-session*
HANDOFF_EOF
            log "Handoff written to: $HANDOFF_FILE"

            THREAD_IDS_JSON="[]"
            if [ -f "$REPO_ROOT/lib/thread_indexer.py" ]; then
                INDEXER_OUTPUT=$(SAMARA_MIND_PATH="$MIND_PATH" MIND_PATH="$MIND_PATH" \
                    PYTHONPATH="$REPO_ROOT" python3 "$REPO_ROOT/lib/thread_indexer.py" \
                    --handoff "$HANDOFF_FILE" --format json 2>> "$LOG_FILE" || echo "")
                if [ -n "$INDEXER_OUTPUT" ]; then
                    THREAD_IDS_JSON=$(echo "$INDEXER_OUTPUT" | jq -c '.thread_ids // []' 2>/dev/null || echo "[]")
                fi
            fi

            # Write handoff event to stream for cross-surface continuity
            if [ -x "$STREAM_CMD" ]; then
                METADATA=$(jq -nc \
                    --arg handoff_path "$HANDOFF_FILE" \
                    --argjson transcript_size "$TRANSCRIPT_SIZE" \
                    --argjson thread_ids "$THREAD_IDS_JSON" \
                    '{handoff_path: $handoff_path, transcript_size: $transcript_size, thread_ids: $thread_ids}')
                if [ -z "$METADATA" ]; then
                    METADATA="{\"handoff_path\": \"$HANDOFF_FILE\", \"transcript_size\": $TRANSCRIPT_SIZE, \"thread_ids\": $THREAD_IDS_JSON}"
                fi

                "$STREAM_CMD" write \
                    --surface cli \
                    --type handoff \
                    --direction internal \
                    --summary "CLI handoff generated" \
                    --session-id "$SESSION_ID" \
                    --metadata "$METADATA" \
                    >> "$LOG_FILE" 2>&1 && \
                    log "Handoff event written to stream" || \
                    log "Failed to write handoff event to stream (non-fatal)"
            fi
        else
            log "Handoff generation failed or empty"
        fi
    else
        log "Session too short for handoff generation (${#CONVERSATION} chars)"
    fi

    log "Distillation complete for session $SESSION_ID"

) >> "$LOG_FILE" 2>&1 &

# Disown so the background process isn't tied to this shell
disown

exit 0
