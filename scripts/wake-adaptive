#!/bin/bash
#
# wake-adaptive - Adaptive wake cycle dispatcher (KeepAlive mode)
#
# Checks the wake scheduler and dispatches to appropriate wake type:
# - full: Full wake cycle (scripts/wake)
# - light: Quick check-in (scripts/wake-light)
# - none: No wake needed
#
# This script runs continuously with launchd KeepAlive, sleeping 900 seconds
# between checks. This ensures crash recovery - if the process dies, launchd
# restarts it immediately rather than waiting for the next interval.
#
# Usage:
#   wake-adaptive [--force TYPE] [--once]
#

set -e

MIND_PATH="${SAMARA_MIND_PATH:-${MIND_PATH:-$HOME/.claude-mind}}"
LOG_FILE="${MIND_PATH}/system/logs/wake-adaptive.log"
HEARTBEAT_FILE="${MIND_PATH}/state/last-heartbeat.txt"
SLEEP_INTERVAL=900  # 15 minutes

# Ensure directories exist
mkdir -p "$(dirname "$LOG_FILE")"
mkdir -p "$(dirname "$HEARTBEAT_FILE")"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Write heartbeat timestamp (used by boot-recovery to detect gaps)
write_heartbeat() {
    echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > "$HEARTBEAT_FILE"
}

# Graceful shutdown handler
RUNNING=true
cleanup() {
    log "Received shutdown signal, exiting gracefully..."
    RUNNING=false
}
trap cleanup SIGTERM SIGINT SIGHUP

# Parse arguments
FORCE_TYPE=""
RUN_ONCE=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        --force)
            FORCE_TYPE="$2"
            shift 2
            ;;
        --once)
            RUN_ONCE=true
            shift
            ;;
        *)
            shift
            ;;
    esac
done

# Main wake check function
do_wake_check() {
    log "Adaptive wake check starting..."

    # Write heartbeat at start of each cycle
    write_heartbeat

    # Check scheduler
    local SCHEDULER_RESULT
    SCHEDULER_RESULT=$("$MIND_PATH/system/bin/wake-scheduler" check 2>/dev/null || echo '{"should_wake": false, "type": "none", "reason": "scheduler unavailable"}')

    local SHOULD_WAKE WAKE_TYPE REASON
    SHOULD_WAKE=$(echo "$SCHEDULER_RESULT" | jq -r '.should_wake // false')
    WAKE_TYPE=$(echo "$SCHEDULER_RESULT" | jq -r '.type // "none"')
    REASON=$(echo "$SCHEDULER_RESULT" | jq -r '.reason // "unknown"')

    # Override with force if specified
    if [ -n "$FORCE_TYPE" ]; then
        SHOULD_WAKE="true"
        WAKE_TYPE="$FORCE_TYPE"
        REASON="Forced: $FORCE_TYPE"
    fi

    log "Decision: should_wake=$SHOULD_WAKE, type=$WAKE_TYPE, reason=$REASON"

    # Evaluate triggers for proactive messaging (only if service is enabled)
    local PROACTIVE_ENABLED
    PROACTIVE_ENABLED=$(jq -r '.services.proactive // true' "$MIND_PATH/system/config.json" 2>/dev/null || echo "true")

    if [ "$PROACTIVE_ENABLED" = "true" ]; then
        log "Evaluating triggers for proactive engagement..."
        "$MIND_PATH/system/bin/check-triggers" 2>&1 || true
        log "Trigger evaluation complete"
    else
        log "Proactive messaging disabled, skipping trigger evaluation"
    fi

    if [ "$SHOULD_WAKE" = "true" ]; then
        case "$WAKE_TYPE" in
            full)
                log "Dispatching to full wake cycle"
                # Regenerate voice style on full wakes (moved from session start)
                [ -x "$MIND_PATH/system/bin/generate-voice-style" ] && \
                    "$MIND_PATH/system/bin/generate-voice-style" --quick >> "$LOG_FILE" 2>&1 || true
                "$MIND_PATH/system/bin/wake" &
                ;;
            light)
                log "Dispatching to light wake cycle"
                "$MIND_PATH/system/bin/wake-light" --reason "$REASON" &
                ;;
            emergency)
                log "Dispatching to emergency wake (using light with urgency)"
                "$MIND_PATH/system/bin/wake-light" --reason "EMERGENCY: $REASON" &
                ;;
            *)
                log "Unknown wake type: $WAKE_TYPE, using light"
                "$MIND_PATH/system/bin/wake-light" --reason "$REASON" &
                ;;
        esac
    else
        log "No wake needed: $REASON"
    fi
}

# Main loop (or single execution with --once)
if [ "$RUN_ONCE" = "true" ]; then
    do_wake_check
else
    log "Starting wake-adaptive in KeepAlive mode (interval: ${SLEEP_INTERVAL}s)"
    while $RUNNING; do
        do_wake_check

        # Sleep in small increments to respond quickly to signals
        SLEPT=0
        while $RUNNING && [ $SLEPT -lt $SLEEP_INTERVAL ]; do
            sleep 10
            SLEPT=$((SLEPT + 10))
        done
    done
    log "Wake-adaptive exiting"
fi
