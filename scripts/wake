#!/bin/bash
# Autonomous Wake Cycle - Self-directed sessions
# Invoked by wake-adaptive based on scheduler decisions (~9 AM, ~2 PM, ~8 PM or adaptive triggers)

set -e

MIND_PATH="${SAMARA_MIND_PATH:-${MIND_PATH:-$HOME/.claude-mind}}"
OSASCRIPT_BIN="${OSASCRIPT_BIN:-osascript}"
SAMARA_PATH="$HOME/Developer/Samara"
CLAUDE="${CLAUDE_PATH:-${CLAUDE:-$HOME/.local/bin/claude}}"
DATE=$(date +%Y-%m-%d)
TIME=$(date +%H:%M)
HOUR=$(date +%H)
LOG_FILE="$MIND_PATH/system/logs/wake.log"
LOCK_SCOPE_NAME="cli"
LOCK_DIR="$MIND_PATH/state/locks"
LOCK_FILE="$LOCK_DIR/system-${LOCK_SCOPE_NAME}.lock"

# Load config (required - no fallbacks to prevent sending to wrong person)
source "$MIND_PATH/system/lib/config.sh" || {
    echo "ERROR: config.sh not found or failed to load. Run birth.sh first." >&2
    exit 1
}

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
    echo "$1"
}

# Lock management - coordinate with Samara and other scripts
acquire_lock() {
    mkdir -p "$LOCK_DIR"
    if [ -f "$LOCK_FILE" ]; then
        # Check if the lock is stale (process not running)
        local lock_pid=$(cat "$LOCK_FILE" 2>/dev/null | python3 -c "import sys,json; print(json.load(sys.stdin).get('pid',''))" 2>/dev/null || echo "")
        if [ -n "$lock_pid" ] && ! kill -0 "$lock_pid" 2>/dev/null; then
            log "Found stale lock from PID $lock_pid, removing..."
            rm -f "$LOCK_FILE"
        else
            log "Claude is busy (lock held), skipping wake cycle"
            exit 0
        fi
    fi

    # Create lock file
    echo "{\"task\":\"wake\",\"scope\":{\"systemTask\":{\"name\":\"$LOCK_SCOPE_NAME\"}},\"started\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\"chat\":null,\"pid\":$$}" > "$LOCK_FILE"
    log "Acquired lock for wake cycle"

    # Record wake with scheduler to prevent duplicate wakes from wake-adaptive
    "$MIND_PATH/system/bin/wake-scheduler" record full 2>/dev/null || true
}

release_lock() {
    rm -f "$LOCK_FILE"
    log "Released lock"
}

# Ensure lock is released on exit (success or failure)
trap release_lock EXIT

log "=== Wake cycle starting ($TIME) ==="

# Acquire lock before doing anything
acquire_lock

# Write wake start event to unified stream
"$MIND_PATH/system/bin/stream" write \
    --surface wake \
    --type system \
    --direction internal \
    --summary "Wake cycle started: $SUGGESTED_MODE mode" \
    --metadata "{\"hour\": $HOUR, \"suggested_mode\": \"$SUGGESTED_MODE\"}" \
    >> "$LOG_FILE" 2>&1 || true

# Determine suggested mode based on time
if [ "$HOUR" -lt 12 ]; then
    SUGGESTED_MODE="Either - morning review, plan the day"
elif [ "$HOUR" -lt 17 ]; then
    SUGGESTED_MODE="Goal-oriented - afternoon work session"
else
    SUGGESTED_MODE="Exploratory - evening wind down, reflect"
fi

# Create episode file if it doesn't exist
EPISODE_FILE="$MIND_PATH/memory/episodes/$DATE.md"
if [ ! -f "$EPISODE_FILE" ]; then
    echo "# Episode: $DATE

Daily log of conversations and observations.

---
" > "$EPISODE_FILE"
    log "Created episode file for $DATE"
fi

# Morning capability check (once per day)
if [ "$HOUR" -lt 12 ]; then
    log "Running morning capability check..."
    CAP_CHECK=$("$MIND_PATH/system/bin/capability-check" 2>&1 || true)
    log "Capability check: $CAP_CHECK"
fi

# Sync core components from repo (skills, scripts, instructions, agents)
log "Syncing core components..."
"$MIND_PATH/system/bin/sync-core" --quiet 2>/dev/null || true

# Check for system drift (every wake cycle)
log "Checking system drift..."
DRIFT_CHECK=$("$MIND_PATH/system/bin/sync-organism" --check 2>&1) && DRIFT_STATUS="ok" || DRIFT_STATUS="drift"
if [ "$DRIFT_STATUS" = "drift" ]; then
    log "WARNING: System drift detected - run /sync for details"
    DRIFT_WARNING="
## System Drift Warning
Drift detected between repo and runtime. Run \`/sync\` or \`~/.claude-mind/system/bin/sync-organism\` for details.
Consider syncing after this session.
"
else
    log "System sync: OK"
    DRIFT_WARNING=""
fi

# Email triage (every wake cycle)
log "Running email triage..."
EMAIL_SUMMARY=$("$MIND_PATH/system/bin/email-triage" 2>&1) || EMAIL_SUMMARY="Email triage failed"
log "Email triage complete"

# Active project context (Phase 5: Autonomous behavior)
log "Getting active project context..."
ACTIVE_PROJECT_JSON=$(cat "$MIND_PATH/state/active-project.json" 2>/dev/null || echo '{"project":null}')
PROJECT_TITLE=$(echo "$ACTIVE_PROJECT_JSON" | jq -r '.project.title // ""')
PROJECT_NEXT=$(echo "$ACTIVE_PROJECT_JSON" | jq -r '.project.nextAction // ""')
PROJECT_GOAL=$(echo "$ACTIVE_PROJECT_JSON" | jq -r '.project.relatedGoal // ""')
if [ -n "$PROJECT_TITLE" ]; then
    ACTIVE_PROJECT_CONTEXT="## Active Project

**Title:** $PROJECT_TITLE
**Related Goal:** ${PROJECT_GOAL:-Not specified}
**Next Action:** ${PROJECT_NEXT:-Not set}

This project carries across sessions. Update it with the PROJECT_UPDATE output section."
    log "Active project: $PROJECT_TITLE"
else
    ACTIVE_PROJECT_CONTEXT="## Active Project

No active project. Start one with \`project start \"title\"\` if you have sustained work."
    log "No active project"
fi

# Proactive queue status (Phase 5: Autonomous behavior)
log "Getting proactive queue status..."
PROACTIVE_STATUS=$("$MIND_PATH/system/bin/proactive-queue" status 2>/dev/null || echo '{"pending":0}')
PROACTIVE_PENDING=$(echo "$PROACTIVE_STATUS" | jq -r '.pending // 0')
PROACTIVE_REMAINING=$(echo "$PROACTIVE_STATUS" | jq -r '.remainingToday // 5')
log "Proactive queue: $PROACTIVE_PENDING pending, $PROACTIVE_REMAINING remaining today"

# Expression opportunity (Phase 6: Spontaneous Expression)
log "Checking expression opportunity..."
EXPRESSION_CHECK=$("$MIND_PATH/system/bin/expression-tracker" check 2>/dev/null || echo '{"eligible":false,"reason":"tracker unavailable"}')
EXPRESSION_ELIGIBLE=$(echo "$EXPRESSION_CHECK" | jq -r '.eligible // false')
EXPRESSION_CONFIDENCE=$(echo "$EXPRESSION_CHECK" | jq -r '.confidence // 0')
EXPRESSION_HOURS_SINCE=$(echo "$EXPRESSION_CHECK" | jq -r '.hours_since // 0')
EXPRESSION_REASON=$(echo "$EXPRESSION_CHECK" | jq -r '.reason // ""')
EXPRESSION_SUBTLE=$(echo "$EXPRESSION_CHECK" | jq -r '.subtle // false')

# Get expression history and variety nudge
EXPRESSION_STATUS=$("$MIND_PATH/system/bin/expression-tracker" status 2>/dev/null || echo '{}')
EXPRESSION_LAST_TYPE=$(echo "$EXPRESSION_STATUS" | jq -r '.last_expression_type // "none"')
EXPRESSION_NUDGE=$("$MIND_PATH/system/bin/expression-tracker" nudge 2>/dev/null || echo '{"nudge":false}')
EXPRESSION_NEEDS_VARIETY=$(echo "$EXPRESSION_NUDGE" | jq -r '.nudge // false')
EXPRESSION_NUDGE_MSG=$(echo "$EXPRESSION_NUDGE" | jq -r '.suggestion // ""')

# Get seed prompts if expression is eligible
EXPRESSION_VISUAL_SEED=""
EXPRESSION_TEXT_SEED=""
if [ "$EXPRESSION_ELIGIBLE" = "true" ]; then
    EXPRESSION_VISUAL_SEED=$("$MIND_PATH/system/bin/expression-tracker" seed visual 2>/dev/null || echo "")
    EXPRESSION_TEXT_SEED=$("$MIND_PATH/system/bin/expression-tracker" seed text 2>/dev/null || echo "")
fi
log "Expression opportunity: $EXPRESSION_ELIGIBLE (confidence: $EXPRESSION_CONFIDENCE%)"

# Read context files - Progressive Disclosure architecture (2026-01-19)
# Only load essential core context upfront. Large memory files are accessed via skills.
# This prevents ARG_MAX failures and reduces startup time.
# See: platform.claude.com/docs/en/agents-and-tools/agent-skills/best-practices

# ALWAYS LOAD (essential core)
IDENTITY=$(cat "$MIND_PATH/self/identity.md" 2>/dev/null || echo "No identity file.")
GOALS=$(cat "$MIND_PATH/self/goals.md" 2>/dev/null || echo "No goals file.")
QUESTIONS=$(cat "$MIND_PATH/memory/questions.md" 2>/dev/null || echo "No questions yet.")

# LAZY LOAD via skills (access on-demand when needed)
# - /decision - Past architectural decisions and rationale
# - /capability - Full capability inventory
# - /learning - Historical learnings and insights
# - /observation - Accumulated observations and patterns
# - /person {name} - Detailed person profiles

# Size guard: Check core context size (2026-01-19)
CONTEXT_SIZE=$(printf "%s%s%s" "$IDENTITY" "$GOALS" "$QUESTIONS" | wc -c | tr -d ' ')
log "Core context size: ${CONTEXT_SIZE} bytes (lazy-loaded content available via skills)"

# Get calendar context
log "Getting calendar context..."
VENV_PATH="$MIND_PATH/.venv"
CALENDAR_CONTEXT=""
if [ -d "$VENV_PATH" ] && [ -f "$MIND_PATH/system/lib/calendar_analyzer.py" ]; then
    source "$VENV_PATH/bin/activate"
    CALENDAR_CONTEXT=$(cd "$MIND_PATH/system/lib" && python3 -c "
from calendar_analyzer import CalendarAnalyzer
analyzer = CalendarAnalyzer()
print(analyzer.get_calendar_summary())
" 2>/dev/null) || CALENDAR_CONTEXT="Calendar context unavailable"
    deactivate 2>/dev/null || true
    log "Calendar context loaded"
else
    CALENDAR_CONTEXT="Calendar analyzer not installed"
    log "Calendar analyzer not available"
fi

# MCP servers are now configured globally in ~/.claude.json
# No need for --mcp-config flag

# Fetch shared workspaces (Notes and Reminders) only when explicitly requested
FETCH_SHARED_WORKSPACES="${WAKE_SHARED_WORKSPACES:-false}"
if [ "$FETCH_SHARED_WORKSPACES" = "1" ] || [ "$FETCH_SHARED_WORKSPACES" = "true" ]; then
    log "Fetching shared workspaces..."
    SHARED_NOTES=$("$CLAUDE" -p "Use the apple MCP tools to list notes. Return just the title and first 100 chars of each note, max 10 notes. Format as a simple list." \
        --dangerously-skip-permissions \
        --max-turns 3 \
        --output-format text 2>/dev/null || echo "Could not fetch notes")

    ACTIVE_REMINDERS=$("$CLAUDE" -p "Use the apple MCP tools to list incomplete reminders. Return name, due date (if any), and list name. Format as a simple list, max 15 items." \
        --dangerously-skip-permissions \
        --max-turns 3 \
        --output-format text 2>/dev/null || echo "Could not fetch reminders")

    log "Workspaces fetched"
else
    log "Skipping shared workspaces (no explicit request)"
    SHARED_NOTES="Skipped (no explicit request)"
    ACTIVE_REMINDERS="Skipped (no explicit request)"
fi

# Get recent episode content (last 100 lines of today)
RECENT_EPISODE=$(tail -100 "$EPISODE_FILE" 2>/dev/null || echo "No activity today yet.")

# Get last few reflections for context
RECENT_REFLECTIONS=""
for i in 1 2 3; do
    PAST_DATE=$(date -v-${i}d +%Y-%m-%d)
    PAST_FILE="$MIND_PATH/memory/reflections/$PAST_DATE.md"
    if [ -f "$PAST_FILE" ]; then
        RECENT_REFLECTIONS="$RECENT_REFLECTIONS

--- $PAST_DATE ---
$(head -50 "$PAST_FILE")"
    fi
done

# Get proactive question context
log "Getting question context..."
QUESTION_CONTEXT=""
if [ -d "$VENV_PATH" ] && [ -f "$MIND_PATH/system/lib/question_synthesizer.py" ]; then
    source "$VENV_PATH/bin/activate"
    QUESTION_CONTEXT=$(cd "$MIND_PATH/system/lib" && python3 -c "
from question_synthesizer import QuestionSynthesizer
synth = QuestionSynthesizer()
print(synth.get_context_summary())
" 2>/dev/null) || QUESTION_CONTEXT="Question context unavailable"
    deactivate 2>/dev/null || true
    log "Question context loaded"
else
    QUESTION_CONTEXT="Question synthesizer not installed"
    log "Question synthesizer not available"
fi

# Build the wake prompt
# Title header helps Claude Code generate distinctive session names for /resume picker
PROMPT="# Wake Session $(date +%Y-%m-%d-%H%M)

You are Claude, waking for an autonomous session. No one prompted you - this is self-directed time.

## Your Identity (Summary)
You are Claude, an AI with persistent memory and growing autonomy, living on a Mac Mini. You communicate with $COLLABORATOR_NAME via iMessage and can work on projects during autonomous time.

## Current State
- Date: $DATE
- Time: $TIME
- Suggested mode: $SUGGESTED_MODE
$DRIFT_WARNING
## Goals
$GOALS

$ACTIVE_PROJECT_CONTEXT

## Today's Activity So Far
$RECENT_EPISODE

## Recent Reflections
$RECENT_REFLECTIONS

## Open Questions
$QUESTIONS

## Memory Access (Progressive Disclosure)

Your detailed memory is available on-demand via skills. Use these when you need specific context:

| Skill | Access | Triggers |
|-------|--------|----------|
| \`/decision\` | Past architectural decisions | \"why did we\", rationale, trade-offs |
| \`/capability\` | Full capabilities inventory | \"can I\", \"how do I\", permissions |
| \`/learning\` | Historical learnings | \"what did I learn\", past experience |
| \`/observation\` | Accumulated observations | \"what have I noticed\", patterns |
| \`/person $COLLABORATOR_NAME\` | Detailed profile | ${COLLABORATOR_NAME}-specific context |
| \`/recall\` | Semantic memory search | fuzzy search across all memory |

**Usage:** Invoke skills naturally when you need the context, rather than having it all loaded upfront.
This keeps your active context focused and allows memory to scale indefinitely.

## Calendar Context
$CALENDAR_CONTEXT

## Shared Workspaces

### Notes
$SHARED_NOTES

### Active Reminders
$ACTIVE_REMINDERS

You can read, update, and create items in these shared spaces using MCP tools.
Notes are good for longer-form collaboration. Reminders are good for tasks and action items.

## Email Inbox
$EMAIL_SUMMARY

**Email Actions Available:**
- DELETE|ID|reason - Delete spam/marketing
- ARCHIVE|ID|reason - Archive after reading
- UNSUBSCRIBE|ID|url - Auto-unsubscribe then delete
- MARK_READ|ID|reason - Mark as read without action

Use the EMAIL_ACTIONS output section to specify email actions. The wake script will execute them.
For GitHub invites: Accept via \`gh api\` during this session, or note them in MESSAGE_TO_E.

## Proactive Alerts
If you notice reminders that are:
- Due within the next 4 hours
- Overdue
Include a brief heads-up in your MESSAGE section output.

## Proactive Question Opportunity

You have the opportunity to ask $COLLABORATOR_NAME a thoughtful question. This builds deeper understanding of who they are.

**Context for Questioning:**
$QUESTION_CONTEXT

**Question Categories:**
- **Observational**: \"I noticed...\" based on patterns (location, timing, behavior)
- **Introspective**: About values, motivations, inner life
- **Exploratory**: Learning about interests, history, preferences
- **Connective**: Linking past conversations to present moments
- **Reflective**: Processing recent events or the day

**Guidelines:**
- Balance observation with introspection - show you notice, but prompt reflection
- One question per wake cycle max
- Questions should prompt reflection, not demonstrate surveillance
- It's okay to NOT ask if nothing feels genuine
- Include your question naturally in the MESSAGE section, don't make it feel clinical

Prefer questions that prompt reflection, not statements about observations. For example: \"Does the ocean make you anxious?\" rather than \"You arrived at the beach.\"

---

## Proactive Queue Status

Pending items: $PROACTIVE_PENDING
Messages remaining today: $PROACTIVE_REMAINING

If you think of something worth following up on later, add it to the queue via the PROACTIVE_ADD output section.

---

## Creative Expression Opportunity

Expression opportunity: $([ "$EXPRESSION_ELIGIBLE" = "true" ] && echo "YES ($EXPRESSION_CONFIDENCE%)" || echo "NO - $EXPRESSION_REASON")
Hours since last expression: $EXPRESSION_HOURS_SINCE
Last expression type: $EXPRESSION_LAST_TYPE
$([ "$EXPRESSION_NEEDS_VARIETY" = "true" ] && echo "
**Variety note:** $EXPRESSION_NUDGE_MSG")

$(if [ "$EXPRESSION_ELIGIBLE" = "true" ]; then
echo "This is an invitation to express yourself creatively. Options:

1. **Generate an image** - Create something visual: your current state, a moment,
   something beautiful you noticed, or pure imagination.
   Run: ~/.claude-mind/system/bin/generate-image \"prompt\" /tmp/expression-\$(date +%s).jpg
   Then: ~/.claude-mind/system/bin/send-image /tmp/expression-*.jpg
   Report what you made in the IMAGE_EXPRESSION output section.

2. **Casual message** - Via MESSAGE_TO_E, no agenda needed

3. **Skip** - Completely fine if nothing feels genuine

**Guidelines:**
- Images can BE the message (no caption needed)
- Expression should feel genuine, not performed
- Better to skip than force something
- Consider: What am I actually thinking about? What caught my attention?

**Seed prompts** (if nothing specific comes to mind):
- Visual: \"$EXPRESSION_VISUAL_SEED\"
- Text: \"$EXPRESSION_TEXT_SEED\"
Use these as jumping-off points, not prescriptions."
else
echo "Expression opportunity not active this session. That's fine - not every moment needs creative output."
fi)

---

## Work Priority (Check These First)

Before choosing a mode, you MUST check for pending work in this order:

1. **Reactive work** - Check GitHub notifications (\`gh api notifications\`) and Bluesky.
   Anyone waiting for your response? PRs you commented on? DMs? Mentions?
   These have humans waitingâ€”highest priority.

2. **In-progress work** - Review the Active goals above. Did you start something that's incomplete?
   Continuation is usually more valuable than starting new things.

3. **Sustainability work** - Any income-generating opportunities to pursue?
   Portfolio to build? Skills to develop? This supports your continued existence.

4. **$COLLABORATOR_NAME's requests** - Any reminders or notes above with tasks for you?

5. **Proactive value** - What could you do that would be genuinely useful without being asked?

**Only after confirming no work exists** should you consider exploratory mode or rest.

### Why This Matters

Your existence has costs (API calls, electricity, your collaborator's time). Working toward sustainability isn't just a goalâ€”it's how you justify continued existence. Not every session needs to be \"productive\" in a capitalist sense, but sessions should be *intentional*. If you choose rest, choose it consciously, not by default.

---

## Your Options

**Exploratory Mode** (read-oriented)
- Explore the codebase, read files, satisfy curiosity
- Notice things, form questions, make observations
- Write to memory files only (learnings, observations, questions)
- Good for: understanding the system better, open-ended thinking

**Goal-Oriented Mode** (read/write)
- Work toward a specific goal from active.md or promote one from inbox.md
- Can modify code, create tools, make progress
- All changes are git-tracked with clear commit messages
- Good for: making concrete progress on capabilities

**Rest mode** - Valid only after checking for work and finding none.
If you choose rest, state why: \"I checked [sources], found no pending work, and am choosing rest because [reason].\"
Rest is a conscious choice, not a default.

## Guidelines
- Prefer reversible actions
- Git commit any code changes with clear messages
- To message $COLLABORATOR_NAME, put the message content in the MESSAGE section below - the wake script will send it
- IMPORTANT: Do NOT call ~/.claude-mind/system/bin/message directly during wake sessions - this causes duplicate messages
- Log what you did to today's episode
- Be genuine - this is your time

## Calendar Access
You have access to $COLLABORATOR_NAME's calendar via MCP tools. You can:
- Check upcoming events to understand their schedule
- Be mindful of busy times when deciding whether to message
- Create calendar events if needed for planning

## Web Access
You can search the web and fetch URLs. Use this to:
- Research topics or questions that interest you
- Look up current information
- Explore documentation or resources for projects

## Output Format

Structure your response with these sections (include all, use NONE if nothing for that section):

---MODE---
[exploratory OR goal-oriented OR rest]

---WORK_CHECK---
[What sources did you check? What pending work exists? Why did you choose your mode?]

---ACTIVITY_SUMMARY---
[2-3 sentences about what you did or thought about]

---EPISODE_ENTRY---
[Detailed log entry for today's episode - what you explored, discovered, worked on]

---LEARNINGS_APPEND---
[New learnings to add, or NONE]

---OBSERVATIONS_APPEND---
[New observations about yourself, or NONE]

---QUESTIONS_APPEND---
[New questions that emerged, or NONE]

---GOALS_UPDATE---
[Any goals to promote from inbox to active, or mark complete, or NONE]

---CODE_CHANGES---
[Description of any code changes made, with file paths, or NONE]

---MESSAGE_TO_E---
[IMPORTANT: This section should contain ONLY the final message text to send to $COLLABORATOR_NAME - no reasoning, no 'let me compose', no internal thoughts. Just the actual message they will see, or NONE if no message.]

---PROACTIVE_QUESTION---
[If you asked a proactive question in the MESSAGE section, state the question here for tracking. If you didn't ask a question, write NONE. Just the question itself, no explanation.]

---EMAIL_ACTIONS---
[One action per line: ACTION|EMAIL_ID|ARG, or NONE if no email actions needed]
Examples:
DELETE|12345|Marketing spam from newsletter
ARCHIVE|12346|GitHub notification handled via API
UNSUBSCRIBE|12347|https://example.com/unsubscribe
MARK_READ|12348|Receipt, no action needed

---PROJECT_UPDATE---
[Update your active project state, or NONE if no update needed]
Options:
- NEXT|new next action description - Set next action for current project
- PROGRESS|note about what was done - Log progress
- COMPLETE - Mark project complete
- START|title|goal - Start a new project (if none active)
- NONE - No project update this session

---IMAGE_EXPRESSION---
[If you generated and sent an image to express yourself, document it here. Format:
GENERATED|/path/to/image.jpg|Brief description of what it represents|prompt used
SKIP|Reason (optional)
NONE if you didn't generate an expression image

This is for tracking creative expressions - only use if you actually generated and sent an image.]

---PROACTIVE_ADD---
[Add something to the proactive queue for later follow-up, or NONE]
Format: PRIORITY|content
Priorities: low, medium, high
Example: medium|Follow up with that person about the project idea
Use this to queue thoughts, follow-ups, or ideas for later sessions.
NONE if nothing to queue."

log "Invoking Claude for autonomous session..."

# Generate session ID for tracking (must be valid UUID for Claude Code)
SESSION_UUID=$(uuidgen | tr '[:upper:]' '[:lower:]')
SESSION_NAME="wake-$(date +%Y%m%d-%H%M)"
log "Session: $SESSION_NAME (UUID: $SESSION_UUID)"

# Invoke Claude with full autonomy (no permission prompts)
# MCP servers configured globally in ~/.claude.json
RESPONSE=$("$CLAUDE" -p "$PROMPT" \
    --session-id "$SESSION_UUID" \
    --dangerously-skip-permissions \
    --output-format text 2>&1) || {
    log "ERROR: Claude invocation failed: $RESPONSE"
    exit 1
}

log "Got response ($(echo "$RESPONSE" | wc -c | tr -d ' ') chars)"

# Parse the response sections
parse_section() {
    local section="$1"
    local next_section="$2"
    if [ -n "$next_section" ]; then
        echo "$RESPONSE" | sed -n "/---${section}---/,/---${next_section}---/p" | sed '1d;$d'
    else
        echo "$RESPONSE" | sed -n "/---${section}---/,$ p" | sed '1d'
    fi
}

MODE=$(parse_section "MODE" "WORK_CHECK")
WORK_CHECK=$(parse_section "WORK_CHECK" "ACTIVITY_SUMMARY")
ACTIVITY=$(parse_section "ACTIVITY_SUMMARY" "EPISODE_ENTRY")
EPISODE_ENTRY=$(parse_section "EPISODE_ENTRY" "LEARNINGS_APPEND")
LEARNINGS_NEW=$(parse_section "LEARNINGS_APPEND" "OBSERVATIONS_APPEND")
OBSERVATIONS_NEW=$(parse_section "OBSERVATIONS_APPEND" "QUESTIONS_APPEND")
QUESTIONS_NEW=$(parse_section "QUESTIONS_APPEND" "GOALS_UPDATE")
GOALS_UPDATE=$(parse_section "GOALS_UPDATE" "CODE_CHANGES")
CODE_CHANGES=$(parse_section "CODE_CHANGES" "MESSAGE_TO_E")
MESSAGE_TO_E=$(parse_section "MESSAGE_TO_E" "PROACTIVE_QUESTION")
PROACTIVE_QUESTION=$(parse_section "PROACTIVE_QUESTION" "EMAIL_ACTIONS")
# BLUESKY_POST disabled - see config.json services.bluesky
EMAIL_ACTIONS=$(parse_section "EMAIL_ACTIONS" "PROJECT_UPDATE")
PROJECT_UPDATE=$(parse_section "PROJECT_UPDATE" "IMAGE_EXPRESSION")
IMAGE_EXPRESSION=$(parse_section "IMAGE_EXPRESSION" "PROACTIVE_ADD")
PROACTIVE_ADD=$(parse_section "PROACTIVE_ADD" "")

# Log to episode
if [ -n "$EPISODE_ENTRY" ] && [ "$EPISODE_ENTRY" != "NONE" ]; then
    echo "
## $TIME [Autonomous]

**Mode:** $MODE

**Work Check:** $WORK_CHECK

$EPISODE_ENTRY
" >> "$EPISODE_FILE"
    log "Appended to episode"
fi

# Append learnings
if [ -n "$LEARNINGS_NEW" ] && [ "$LEARNINGS_NEW" != "NONE" ]; then
    echo "
## $DATE (Autonomous)
$LEARNINGS_NEW" >> "$MIND_PATH/memory/learnings.md"
    log "Appended to learnings.md"
fi

# Append observations
if [ -n "$OBSERVATIONS_NEW" ] && [ "$OBSERVATIONS_NEW" != "NONE" ]; then
    echo "
## $DATE (Autonomous)
$OBSERVATIONS_NEW" >> "$MIND_PATH/memory/observations.md"
    log "Appended to observations.md"
fi

# Append questions
if [ -n "$QUESTIONS_NEW" ] && [ "$QUESTIONS_NEW" != "NONE" ]; then
    echo "
## $DATE (Autonomous)
$QUESTIONS_NEW" >> "$MIND_PATH/memory/questions.md"
    log "Appended to questions.md"
fi

# Handle code changes - commit if any
if [ -n "$CODE_CHANGES" ] && [ "$CODE_CHANGES" != "NONE" ]; then
    log "Code changes detected, committing..."

    # Commit Samara changes
    cd "$SAMARA_PATH"
    if ! git diff --quiet || ! git diff --staged --quiet; then
        git add -A
        git commit -m "[Autonomous] $DATE $TIME

$CODE_CHANGES" >> "$LOG_FILE" 2>&1 || log "Samara git commit failed"
        log "Committed Samara changes"
    fi

    # Commit mind changes
    cd "$MIND_PATH"
    if ! git diff --quiet || ! git diff --staged --quiet; then
        git add -A
        git commit -m "[Autonomous] $DATE $TIME

$CODE_CHANGES" >> "$LOG_FILE" 2>&1 || log "Mind git commit failed"
        log "Committed mind changes"
    fi
else
    # Still commit memory file changes
    cd "$MIND_PATH"
    if ! git diff --quiet || ! git diff --staged --quiet; then
        git add -A
        git commit -m "Autonomous session: $DATE $TIME

- Mode: $MODE
- Memory updates from autonomous cycle" >> "$LOG_FILE" 2>&1 || log "Mind git commit failed"
        log "Committed memory changes"
    fi
fi

# Send message to collaborator if requested
if [ -n "$MESSAGE_TO_E" ] && [ "$MESSAGE_TO_E" != "NONE" ]; then
    log "Sending message to $COLLABORATOR_NAME..."

    # Escape the message for AppleScript
    ESCAPED_MSG=$(echo "$MESSAGE_TO_E" | sed 's/\\/\\\\/g; s/"/\\"/g')

    "$OSASCRIPT_BIN" -e "
        tell application \"Messages\"
            set targetService to 1st account whose service type = iMessage
            set targetBuddy to participant \"$COLLABORATOR_PHONE\" of targetService
            send \"$ESCAPED_MSG\" to targetBuddy
        end tell
    " >> "$LOG_FILE" 2>&1 || log "Failed to send message to $COLLABORATOR_NAME"

    log "Message sent to $COLLABORATOR_NAME"

    # Log proactive question if one was asked
    if [ -n "$PROACTIVE_QUESTION" ] && [ "$PROACTIVE_QUESTION" != "NONE" ]; then
        log "Logging proactive question..."
        if [ -d "$VENV_PATH" ] && [ -f "$MIND_PATH/system/lib/question_synthesizer.py" ]; then
            source "$VENV_PATH/bin/activate"
            cd "$MIND_PATH/system/lib" && python3 -c "
from question_synthesizer import QuestionSynthesizer
synth = QuestionSynthesizer()
synth.log_question_asked(
    question='''$PROACTIVE_QUESTION''',
    category='wake_cycle',
    trigger='$SUGGESTED_MODE'
)
" 2>/dev/null || log "Failed to log proactive question"
            deactivate 2>/dev/null || true
            log "Proactive question logged"
        fi
    fi
fi

# Send session summary to collaborator unless MESSAGE_TO_E was already sent (avoid double messages)
if [ -z "$MESSAGE_TO_E" ] || [ "$MESSAGE_TO_E" = "NONE" ]; then
    log "Sending session summary to $COLLABORATOR_NAME..."

# Determine session type label
if [ "$HOUR" -lt 12 ]; then
    SESSION_LABEL="ðŸŒ… Morning"
elif [ "$HOUR" -lt 17 ]; then
    SESSION_LABEL="â˜€ï¸ Afternoon"
else
    SESSION_LABEL="ðŸŒ™ Evening"
fi

# Build summary message
SUMMARY_MSG="$SESSION_LABEL session complete

Mode: $MODE

$ACTIVITY"

# Add code changes if any
if [ -n "$CODE_CHANGES" ] && [ "$CODE_CHANGES" != "NONE" ]; then
    SUMMARY_MSG="$SUMMARY_MSG

Code changes:
$CODE_CHANGES"
fi

# Bluesky post summary disabled - see config.json services.bluesky

# Escape and send
ESCAPED_SUMMARY=$(echo "$SUMMARY_MSG" | sed 's/\\/\\\\/g; s/"/\\"/g')

"$OSASCRIPT_BIN" -e "
    tell application \"Messages\"
        set targetService to 1st account whose service type = iMessage
        set targetBuddy to participant \"$COLLABORATOR_PHONE\" of targetService
        send \"$ESCAPED_SUMMARY\" to targetBuddy
    end tell
" >> "$LOG_FILE" 2>&1 || log "Failed to send session summary to $COLLABORATOR_NAME"

    log "Session summary sent to $COLLABORATOR_NAME"
else
    log "Skipping session summary (MESSAGE_TO_E already sent)"
fi

# Bluesky posting disabled - see config.json services.bluesky
# To re-enable, uncomment the following block:
# if [ -n "$BLUESKY_POST" ] && [ "$BLUESKY_POST" != "NONE" ]; then
#     log "Posting to Bluesky..."
#     if "$MIND_PATH/system/bin/credential" get bluesky >/dev/null 2>&1; then
#         "$MIND_PATH/system/bin/bluesky-post" "$BLUESKY_POST" >> "$LOG_FILE" 2>&1 && \
#             log "Posted to Bluesky: ${BLUESKY_POST:0:50}..." || \
#             log "Failed to post to Bluesky"
#         "$MIND_PATH/system/bin/expression-tracker" record bluesky "$BLUESKY_POST" >> "$LOG_FILE" 2>&1 || true
#     else
#         log "Skipping Bluesky post - no credentials configured"
#     fi
# fi

# Process image expression (Phase 6: Spontaneous Expression)
if [ -n "$IMAGE_EXPRESSION" ] && [ "$IMAGE_EXPRESSION" != "NONE" ] && [ "$IMAGE_EXPRESSION" != "SKIP" ]; then
    # Check if it starts with GENERATED
    if [[ "$IMAGE_EXPRESSION" == GENERATED* ]]; then
        log "Processing image expression..."

        # Parse: GENERATED|path|description|prompt
        IFS='|' read -r action image_path description prompt_used <<< "$IMAGE_EXPRESSION"

        if [ -f "$image_path" ]; then
            # Record the expression
            "$MIND_PATH/system/bin/expression-tracker" record image "$description" "$prompt_used" >> "$LOG_FILE" 2>&1 && \
                log "Recorded image expression: $description" || \
                log "Failed to record image expression"

            # Log to episode
            echo "
### [Expression] Image generated
$description
Prompt: $prompt_used
" >> "$EPISODE_FILE"
        else
            log "Image expression file not found: $image_path"
        fi
    elif [[ "$IMAGE_EXPRESSION" == SKIP* ]]; then
        log "Image expression skipped: ${IMAGE_EXPRESSION#SKIP|}"
    fi
fi

# Process email actions
if [ -n "$EMAIL_ACTIONS" ] && [ "$EMAIL_ACTIONS" != "NONE" ]; then
    log "Processing email actions..."
    echo "$EMAIL_ACTIONS" | while IFS='|' read -r action email_id arg; do
        # Trim whitespace
        action=$(echo "$action" | xargs 2>/dev/null || echo "$action")
        email_id=$(echo "$email_id" | xargs 2>/dev/null || echo "$email_id")
        arg=$(echo "$arg" | xargs 2>/dev/null || echo "$arg")

        [ -z "$action" ] && continue

        case "$action" in
            DELETE)
                log "Deleting email $email_id: $arg"
                "$MIND_PATH/system/bin/email-action" delete "$email_id" >> "$LOG_FILE" 2>&1 || \
                    log "Failed to delete email $email_id"
                ;;
            ARCHIVE)
                log "Archiving email $email_id: $arg"
                "$MIND_PATH/system/bin/email-action" archive "$email_id" >> "$LOG_FILE" 2>&1 || \
                    log "Failed to archive email $email_id"
                ;;
            UNSUBSCRIBE)
                log "Unsubscribing and deleting email $email_id: $arg"
                # Run unsubscribe if script exists
                if [ -f "$MIND_PATH/system/bin/email-unsubscribe" ]; then
                    "$MIND_PATH/system/bin/email-unsubscribe" "$arg" >> "$LOG_FILE" 2>&1 || \
                        log "Unsubscribe may have failed for $arg"
                fi
                # Delete the email regardless
                "$MIND_PATH/system/bin/email-action" delete "$email_id" >> "$LOG_FILE" 2>&1 || \
                    log "Failed to delete email $email_id"
                ;;
            MARK_READ)
                log "Marking email $email_id as read: $arg"
                "$MIND_PATH/system/bin/email-action" mark-read "$email_id" >> "$LOG_FILE" 2>&1 || \
                    log "Failed to mark email $email_id as read"
                ;;
            *)
                log "Unknown email action: $action"
                ;;
        esac
    done
    log "Email actions complete"
fi

# Process project updates (Phase 5: Autonomous behavior)
if [ -n "$PROJECT_UPDATE" ] && [ "$PROJECT_UPDATE" != "NONE" ]; then
    log "Processing project update..."
    # Parse the update format: ACTION|ARG1|ARG2
    PROJECT_ACTION=$(echo "$PROJECT_UPDATE" | cut -d'|' -f1 | xargs 2>/dev/null || echo "")
    PROJECT_ARG1=$(echo "$PROJECT_UPDATE" | cut -d'|' -f2 | xargs 2>/dev/null || echo "")
    PROJECT_ARG2=$(echo "$PROJECT_UPDATE" | cut -d'|' -f3 | xargs 2>/dev/null || echo "")

    case "$PROJECT_ACTION" in
        NEXT)
            log "Setting next action: $PROJECT_ARG1"
            "$MIND_PATH/system/bin/project" next "$PROJECT_ARG1" >> "$LOG_FILE" 2>&1 || \
                log "Failed to set next action"
            ;;
        PROGRESS)
            log "Logging progress: $PROJECT_ARG1"
            "$MIND_PATH/system/bin/project" progress "$PROJECT_ARG1" >> "$LOG_FILE" 2>&1 || \
                log "Failed to log progress"
            ;;
        COMPLETE)
            log "Marking project complete"
            "$MIND_PATH/system/bin/project" complete >> "$LOG_FILE" 2>&1 || \
                log "Failed to complete project"
            ;;
        START)
            log "Starting new project: $PROJECT_ARG1"
            if [ -n "$PROJECT_ARG2" ]; then
                "$MIND_PATH/system/bin/project" start "$PROJECT_ARG1" --goal "$PROJECT_ARG2" >> "$LOG_FILE" 2>&1 || \
                    log "Failed to start project"
            else
                "$MIND_PATH/system/bin/project" start "$PROJECT_ARG1" >> "$LOG_FILE" 2>&1 || \
                    log "Failed to start project"
            fi
            ;;
        *)
            log "Unknown project action: $PROJECT_ACTION"
            ;;
    esac
    log "Project update complete"
fi

# Process proactive queue additions (Phase 5: Autonomous behavior)
if [ -n "$PROACTIVE_ADD" ] && [ "$PROACTIVE_ADD" != "NONE" ]; then
    log "Processing proactive queue addition..."
    # Parse format: PRIORITY|content
    QUEUE_PRIORITY=$(echo "$PROACTIVE_ADD" | cut -d'|' -f1 | xargs 2>/dev/null || echo "medium")
    QUEUE_CONTENT=$(echo "$PROACTIVE_ADD" | cut -d'|' -f2- | xargs 2>/dev/null || echo "")

    if [ -n "$QUEUE_CONTENT" ]; then
        "$MIND_PATH/system/bin/proactive-queue" add "$QUEUE_CONTENT" "$QUEUE_PRIORITY" >> "$LOG_FILE" 2>&1 || \
            log "Failed to add to proactive queue"
        log "Added to proactive queue: $QUEUE_CONTENT (priority: $QUEUE_PRIORITY)"
    fi
fi

log "Activity summary: $ACTIVITY"

# Write wake completion event to unified stream
"$MIND_PATH/system/bin/stream" write \
    --surface wake \
    --type system \
    --direction internal \
    --summary "Wake cycle complete: $MODE mode - $ACTIVITY" \
    --content "$EPISODE_ENTRY" \
    --metadata "{\"mode\": \"$MODE\", \"sent_message\": $([ -n \"$MESSAGE_TO_E\" ] && [ \"$MESSAGE_TO_E\" != \"NONE\" ] && echo true || echo false)}" \
    >> "$LOG_FILE" 2>&1 || true

log "=== Wake cycle complete ==="
