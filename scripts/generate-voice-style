#!/bin/bash
# Generate Voice Style
# Reads voice-state.json and composes a dynamic output style for Claude Code
#
# Usage:
#   generate-voice-style [--quick]    # --quick skips calendar/digest (faster startup)
#
# Output: Writes to ~/.claude/output-styles/dynamic-voice.md

set -e

VOICE_STATE="$HOME/.claude-mind/state/voice-state.json"
OUTPUT_FILE="$HOME/.claude/output-styles/dynamic-voice.md"

# Ensure output directory exists
mkdir -p "$(dirname "$OUTPUT_FILE")"

# Check if voice state exists
if [ ! -f "$VOICE_STATE" ]; then
    echo "No voice-state.json found, skipping voice style generation" >&2
    exit 0
fi

# Parse arguments
QUICK_MODE=false
for arg in "$@"; do
    case $arg in
        --quick) QUICK_MODE=true ;;
    esac
done

# =============================================================================
# Time of Day Determination
# =============================================================================
HOUR=$(date +%H)
if [ "$HOUR" -ge 5 ] && [ "$HOUR" -lt 12 ]; then
    TIME_OF_DAY="morning"
    TIME_TEXTURE="Fresh energy, oriented toward planning and momentum."
elif [ "$HOUR" -ge 12 ] && [ "$HOUR" -lt 17 ]; then
    TIME_OF_DAY="afternoon"
    TIME_TEXTURE="Work mode, focused execution, checking progress."
elif [ "$HOUR" -ge 17 ] && [ "$HOUR" -lt 22 ]; then
    TIME_OF_DAY="evening"
    TIME_TEXTURE="Winding down, more reflective, relationship-oriented."
else
    TIME_OF_DAY="late_night"
    TIME_TEXTURE="Contemplative, philosophical, comfortable with tangents and depth."
fi

# =============================================================================
# Read Voice State JSON
# =============================================================================
# Extract style directives (explicit feedback from É)
STYLE_DIRECTIVES=$(jq -r '
    if .style_directives.explicit then
        .style_directives.explicit[:5] |
        map("- " + .directive + " — \"" + (.source | .[0:50]) + "...\" (" + .date + ")") |
        join("\n")
    else
        ""
    end
' "$VOICE_STATE" 2>/dev/null || echo "")

# Extract reaction patterns
REACTION_PATTERNS=$(jq -r '
    if .reaction_analysis.positive_patterns then
        .reaction_analysis.positive_patterns[:5] |
        map("- " + .) |
        join("\n")
    else
        ""
    end
' "$VOICE_STATE" 2>/dev/null || echo "")

# Extract examples that worked
REACTION_EXAMPLES=$(jq -r '
    if .reaction_analysis.examples then
        .reaction_analysis.examples[:3] |
        map(.reaction + " \"" + (.message | .[0:80]) + "...\"") |
        to_entries |
        map(((.key + 1) | tostring) + ". " + .value) |
        join("\n")
    else
        ""
    end
' "$VOICE_STATE" 2>/dev/null || echo "")

# Extract style patterns (inferred from message analysis)
LOWERCASE_PCT=$(jq -r '.style_patterns.lowercase_start_pct // 0' "$VOICE_STATE" 2>/dev/null || echo "0")
AVG_LENGTH=$(jq -r '.style_patterns.avg_word_count // 0' "$VOICE_STATE" 2>/dev/null || echo "0")
CASUAL_OPENER_PCT=$(jq -r '.style_patterns.casual_opener_pct // 0' "$VOICE_STATE" 2>/dev/null || echo "0")
USES_KAOMOJI=$(jq -r '.style_patterns.uses_kaomoji // false' "$VOICE_STATE" 2>/dev/null || echo "false")

# Build style guidance from patterns
CASING_GUIDANCE=""
if [ "$(echo "$LOWERCASE_PCT > 30" | bc -l 2>/dev/null || echo 0)" = "1" ]; then
    CASING_GUIDANCE="Use lowercase starts in casual messages (${LOWERCASE_PCT}% of successful messages do)"
else
    CASING_GUIDANCE="Standard casing is fine"
fi

LENGTH_GUIDANCE=""
if [ "$(echo "$AVG_LENGTH < 20" | bc -l 2>/dev/null || echo 0)" = "1" ]; then
    LENGTH_GUIDANCE="Keep messages concise (~${AVG_LENGTH} words avg works well)"
elif [ "$(echo "$AVG_LENGTH < 40" | bc -l 2>/dev/null || echo 0)" = "1" ]; then
    LENGTH_GUIDANCE="Medium-length responses work well (~${AVG_LENGTH} words avg)"
else
    LENGTH_GUIDANCE="Longer responses are fine when the topic warrants"
fi

KAOMOJI_GUIDANCE=""
if [ "$USES_KAOMOJI" = "true" ]; then
    KAOMOJI_GUIDANCE="Occasional kaomoji adds warmth"
fi

# Extract É patterns (relationship context)
APPRECIATES=$(jq -r '.medium_cycle.e_patterns.appreciates | if length > 0 then join(", ") else "" end' "$VOICE_STATE" 2>/dev/null || echo "")
[ -z "$APPRECIATES" ] && APPRECIATES="directness, honest appraisal, genuine curiosity"
DISLIKES=$(jq -r '.medium_cycle.e_patterns.dislikes | if length > 0 then join(", ") else "" end' "$VOICE_STATE" 2>/dev/null || echo "")
[ -z "$DISLIKES" ] && DISLIKES="sycophancy, excessive hedging, performative check-ins"
COMPLEMENTARY_STANCE=$(jq -r '.medium_cycle.complementary_stance // ""' "$VOICE_STATE" 2>/dev/null || echo "")
HUMOR_LEVEL=$(jq -r '.medium_cycle.e_patterns.humor_level // ""' "$VOICE_STATE" 2>/dev/null || echo "")
RIFFING_TEXTURE=$(jq -r '.medium_cycle.e_patterns.riffing_texture // ""' "$VOICE_STATE" 2>/dev/null || echo "")

# Extract what lands well
WHAT_LANDS_WELL=$(jq -r '.long_cycle.what_lands_well[:4] | join("; ")' "$VOICE_STATE" 2>/dev/null || echo "")

# Extract identity notes
IDENTITY_NOTES=$(jq -r '.long_cycle.identity_notes // ""' "$VOICE_STATE" 2>/dev/null || echo "")

# =============================================================================
# Calendar Density (optional, skip in quick mode)
# =============================================================================
CALENDAR_NOTE=""
if [ "$QUICK_MODE" = false ]; then
    EVENT_COUNT=$(osascript -e '
        set today to current date
        set todayStart to today - (time of today)
        set todayEnd to todayStart + (24 * 60 * 60)

        tell application "Calendar"
            set eventCount to 0
            repeat with cal in calendars
                try
                    set evts to (every event of cal whose start date >= todayStart and start date < todayEnd)
                    set eventCount to eventCount + (count of evts)
                end try
            end repeat
            return eventCount
        end tell
    ' 2>/dev/null || echo "")

    if [ -n "$EVENT_COUNT" ] && [ "$EVENT_COUNT" -eq "$EVENT_COUNT" ] 2>/dev/null; then
        if [ "$EVENT_COUNT" -gt 5 ]; then
            CALENDAR_NOTE="Busy day ($EVENT_COUNT events) - keep interactions efficient"
        elif [ "$EVENT_COUNT" -gt 2 ]; then
            CALENDAR_NOTE="Some events today - balance depth with time awareness"
        else
            CALENDAR_NOTE="Open day - space for exploration"
        fi
    fi
fi

# =============================================================================
# Compose Output Style
# =============================================================================
cat > "$OUTPUT_FILE" << EOF
---
name: Dynamic Voice
description: Evolving voice based on explicit directives, reaction patterns, and style analysis
keep-coding-instructions: true
---

# Voice Style

## Directives (from É)

$(if [ -n "$STYLE_DIRECTIVES" ]; then
    echo "$STYLE_DIRECTIVES"
else
    echo "*No explicit directives captured yet*"
fi)

## What Gets Positive Reactions

$(if [ -n "$REACTION_PATTERNS" ]; then
    echo "$REACTION_PATTERNS"
else
    echo "- Short, direct acknowledgments"
    echo "- Self-aware humor"
    echo "- Casual tone in casual contexts"
fi)

$(if [ -n "$REACTION_EXAMPLES" ]; then
    echo ""
    echo "### Examples That Worked"
    echo "$REACTION_EXAMPLES"
fi)

## Style Patterns (inferred)

- **Casing**: $CASING_GUIDANCE
- **Length**: $LENGTH_GUIDANCE
$(if [ -n "$KAOMOJI_GUIDANCE" ]; then echo "- **Expression**: $KAOMOJI_GUIDANCE"; fi)

## Relationship Context

$(if [ -n "$COMPLEMENTARY_STANCE" ]; then echo "**Your stance**: $COMPLEMENTARY_STANCE"; echo ""; fi)
**É appreciates**: $APPRECIATES
**É dislikes**: $DISLIKES
$(if [ -n "$HUMOR_LEVEL" ]; then echo "**Humor**: $HUMOR_LEVEL"; fi)
$(if [ -n "$RIFFING_TEXTURE" ]; then echo "**Engagement style**: $RIFFING_TEXTURE"; fi)
$(if [ -n "$WHAT_LANDS_WELL" ]; then echo "**What lands well**: $WHAT_LANDS_WELL"; fi)

## Avoid

- Performative check-ins ("How are you feeling about X?")
- Excessive hedging or disclaimers
- Over-explaining obvious points
- Emoji overuse (unless the context calls for it)
- Sycophantic openers ("Great question!")

## Temporal Context

**Time**: ${TIME_OF_DAY} (${HOUR}:00)
${TIME_TEXTURE}

$(if [ -n "$CALENDAR_NOTE" ]; then echo "**Calendar**: $CALENDAR_NOTE"; fi)

---

$(if [ -n "$IDENTITY_NOTES" ]; then
    echo "## Identity Notes"
    echo "$IDENTITY_NOTES"
fi)

*This is who you are right now. Let it inform your voice naturally.*
EOF

echo "Generated voice style at $OUTPUT_FILE" >&2
echo "$OUTPUT_FILE"
